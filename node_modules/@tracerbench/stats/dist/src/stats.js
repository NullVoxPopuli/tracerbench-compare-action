"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3_array_1 = require("d3-array");
const d3_scale_1 = require("d3-scale");
const confidence_interval_1 = require("./confidence-interval");
const utils_1 = require("./utils");
// ! all stats assume microseconds from tracerbench and round to milliseconds
class Stats {
    constructor(options) {
        const { name, control, experiment, confidenceLevel } = options;
        // explicitly for NOT sorted
        this.controlMS = control.map((x) => Math.round(utils_1.convertMicrosecondsToMS(x)));
        this.experimentMS = experiment.map((x) => Math.round(utils_1.convertMicrosecondsToMS(x)));
        // explicitly for sortedMS
        const controlSortedMS = control.map((x) => Math.round(utils_1.convertMicrosecondsToMS(x)));
        const experimentSortedMS = experiment.map((x) => Math.round(utils_1.convertMicrosecondsToMS(x)));
        this.controlSortedMS = controlSortedMS.sort((a, b) => a - b);
        this.experimentSortedMS = experimentSortedMS.sort((a, b) => a - b);
        this.name = name;
        this.sampleCount = {
            control: this.controlSortedMS.length,
            experiment: this.experimentSortedMS.length
        };
        this.range = this.getRange(this.controlSortedMS, this.experimentSortedMS);
        this.sparkLine = {
            control: this.getSparkline(this.getHistogram(this.range, this.controlSortedMS)),
            experiment: this.getSparkline(this.getHistogram(this.range, this.experimentSortedMS))
        };
        this.confidenceIntervals = {
            80: this.getConfidenceInterval(this.controlSortedMS, this.experimentSortedMS, 0.8),
            85: this.getConfidenceInterval(this.controlSortedMS, this.experimentSortedMS, 0.85),
            90: this.getConfidenceInterval(this.controlSortedMS, this.experimentSortedMS, 0.9),
            95: this.getConfidenceInterval(this.controlSortedMS, this.experimentSortedMS, 0.95),
            99: this.getConfidenceInterval(this.controlSortedMS, this.experimentSortedMS, 0.99),
            995: this.getConfidenceInterval(this.controlSortedMS, this.experimentSortedMS, 0.995),
            999: this.getConfidenceInterval(this.controlSortedMS, this.experimentSortedMS, 0.999)
        };
        this.confidenceInterval = this.getConfidenceInterval(this.controlSortedMS, this.experimentSortedMS, confidenceLevel);
        this.estimator = Math.round(this.getHodgesLehmann(this.controlSortedMS, this.experimentSortedMS));
        this.sevenFigureSummary = {
            control: this.getSevenFigureSummary(this.controlSortedMS),
            experiment: this.getSevenFigureSummary(this.experimentSortedMS)
        };
        this.outliers = {
            control: this.getOutliers(this.controlSortedMS, this.sevenFigureSummary.control),
            experiment: this.getOutliers(this.experimentSortedMS, this.sevenFigureSummary.experiment)
        };
    }
    getOutliers(a, sevenFigSum) {
        const IQR = sevenFigSum[75] - sevenFigSum[25];
        const obj = {
            IQR,
            lowerOutlier: Math.floor(sevenFigSum[25] - 1.5 * IQR),
            upperOutlier: Math.round(sevenFigSum[75] + 1.5 * IQR),
            outliers: []
        };
        a.forEach((n) => {
            const roundedN = Math.round(n);
            if (roundedN < obj.lowerOutlier || roundedN > obj.upperOutlier) {
                obj.outliers.push(roundedN);
            }
        });
        return obj;
    }
    getSevenFigureSummary(a) {
        return {
            min: Math.round(Math.min.apply(null, a)),
            max: Math.round(Math.max.apply(null, a)),
            10: Math.round(d3_array_1.quantile(a, 0.1)),
            25: Math.round(d3_array_1.quantile(a, 0.25)),
            50: Math.round(d3_array_1.quantile(a, 0.5)),
            75: Math.round(d3_array_1.quantile(a, 0.75)),
            90: Math.round(d3_array_1.quantile(a, 0.9))
        };
    }
    getConfidenceInterval(control, experiment, confidenceLevel = 0.95) {
        const ci = confidence_interval_1.confidenceInterval(control, experiment, confidenceLevel);
        const isSig = (ci[0] < 0 && 0 < ci[1]) ||
            (ci[0] > 0 && 0 > ci[1]) ||
            (ci[0] === 0 && ci[1] === 0)
            ? false
            : true;
        return {
            min: Math.round(Math.ceil(ci[0] * 100) / 100),
            max: Math.round(Math.ceil(ci[1] * 100) / 100),
            isSig
        };
    }
    getHodgesLehmann(control, experiment) {
        const crossProduct = d3_array_1.cross(control, experiment, (a, b) => a - b).sort((a, b) => a - b);
        return d3_array_1.quantile(crossProduct, 0.5);
    }
    getRange(control, experiment) {
        const a = control.concat(experiment);
        return { min: Math.min(...a), max: Math.max(...a) };
    }
    getHistogram(range, a) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const x = d3_scale_1.scaleLinear()
            .domain([range.min, range.max])
            .range([range.min, range.max]);
        const h = d3_array_1.histogram()
            .value((d) => {
            return d;
        })
            .domain(x.domain())
            .thresholds(x.ticks());
        return h(a).map((i) => {
            return i.length;
        });
    }
    getSparkline(numbers, min = Math.min.apply(null, numbers), max = Math.max.apply(null, numbers)) {
        function lshift(n, bits) {
            return Math.floor(n) * Math.pow(2, bits);
        }
        const ticks = ['▁', '▂', '▃', '▄', '▅', '▆', '▇', '█'];
        const results = [];
        let f = Math.floor(lshift(max - min, 8) / (ticks.length - 1));
        if (f < 1) {
            f = 1;
        }
        numbers.forEach((n) => {
            const value = ticks[Math.floor(lshift(n - min, 8) / f)];
            results.push(value);
        });
        return `${results.join('')}`;
    }
}
exports.Stats = Stats;
//# sourceMappingURL=stats.js.map