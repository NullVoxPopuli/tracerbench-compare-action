"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = require("fs-extra");
const fs = require("fs-extra");
const path = require("path");
const trace_1 = require("../trace");
const render_events_1 = require("../trace/render-events");
const aggregator_1 = require("./aggregator");
const module_matcher_1 = require("./module-matcher");
const reporter_1 = require("./reporter");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const cloneDeep = require('lodash.clonedeep');
exports.AUTO_ADD_CAT = 'Auto Added Module Paths';
async function analyze(options) {
    const { harJSON, traceEvents, methods, heuristics } = options;
    const trace = loadTrace(traceEvents);
    const profile = getCPUProfile(trace);
    const { hierarchy } = profile;
    const modMatcher = new module_matcher_1.ModuleMatcher(hierarchy, harJSON);
    exportHierarchy(traceEvents, hierarchy, trace, undefined, modMatcher);
    const categories = formatCategories(heuristics, methods);
    const allMethods = methodsFromCategories(categories);
    addRemainingModules(allMethods, categories, modMatcher);
    aggregator_1.verifyMethods(allMethods);
    const aggregations = aggregator_1.aggregate(hierarchy, allMethods, harJSON, modMatcher);
    const collapsed = aggregator_1.collapseCallFrames(aggregations);
    const renderNodes = getRenderingNodes(hierarchy);
    const hierarchyReports = [];
    renderNodes.forEach((node) => {
        const renderAgg = aggregator_1.aggregate(node, allMethods, harJSON, modMatcher);
        const renderCollapsed = aggregator_1.collapseCallFrames(renderAgg);
        hierarchyReports.push(reporter_1.default(aggregator_1.categorizeAggregations(renderCollapsed, categories)));
    });
    return {
        node: reporter_1.default(aggregator_1.categorizeAggregations(collapsed, categories)),
        hierarchyReports
    };
}
exports.analyze = analyze;
function loadTrace(traceEvents) {
    const trace = new trace_1.Trace();
    trace.addEvents(traceEvents);
    trace.buildModel();
    return trace;
}
/**
 * This will add all module paths to locators/categories, except for those already matched by
 * user provided heuristic config entries which specify a non-".*" module name regex.
 */
function addRemainingModules(locators, categories, modMatcher) {
    const allModules = modMatcher.getModuleList();
    categories[exports.AUTO_ADD_CAT] = [];
    allModules.forEach((moduleName) => {
        // If the locator is going to match an entire module anyway, don't add that module to the auto
        // generated list of module aggergations.
        const found = locators.find((locator) => {
            return locator.functionName === '.*'
                ? locator.moduleNameRegex.test(moduleName)
                : false;
        });
        if (!found) {
            const newLocator = {
                functionName: '.*',
                functionNameRegex: /.*/,
                moduleName,
                moduleNameRegex: new RegExp(`^${moduleName}$`)
            };
            locators.push(newLocator);
            categories[exports.AUTO_ADD_CAT].push(newLocator);
        }
    });
}
exports.addRemainingModules = addRemainingModules;
function formatCategories(heuristics, methods = ['']
// eslint-disable-next-line @typescript-eslint/no-explicit-any
) {
    if (heuristics) {
        const stats = fs.statSync(heuristics);
        const categories = {};
        if (stats.isDirectory()) {
            const files = fs.readdirSync(heuristics);
            files.map((file) => {
                const name = path.basename(file).replace('.json', '');
                const methods = JSON.parse(fs.readFileSync(`${heuristics}/${file}`, 'utf8'));
                methods.forEach((method) => {
                    if (method.functionName === '*') {
                        method.functionName = '.*';
                    }
                    method.functionNameRegex = new RegExp(`^${method.functionName}$`);
                    if (method.moduleName === '*') {
                        method.moduleName = '.*';
                    }
                    method.moduleNameRegex = new RegExp(`^${method.moduleName}$`);
                });
                categories[name] = methods;
            });
        }
        else {
            const category = path.basename(heuristics).replace('.json', '');
            const methods2 = JSON.parse(fs.readFileSync(heuristics, 'utf8'));
            if (methods2.functionName === '*') {
                methods2.functionName = '.*';
            }
            methods2.functionNameRegex = new RegExp(`^${methods2.functionName}$`);
            if (methods2.moduleName === '*') {
                methods2.moduleName = '.*';
            }
            methods2.moduleNameRegex = new RegExp(`^${methods2.moduleName}$`);
            categories[category] = methods2;
        }
        return categories;
    }
    else {
        if (methods === undefined) {
            throw new Error(`Error: Must pass a list of method names.`);
        }
        const addHocLocators = methods.map((method) => {
            return {
                functionName: method,
                functionNameRegex: new RegExp(`^${method}$`),
                moduleName: '*',
                moduleNameRegex: /.*/
            };
        });
        return { 'Auto Added Module Paths': addHocLocators };
    }
}
function exportHierarchy(rawTraceData, hierarchy, trace, filename = 'trace-processed', modMatcher) {
    const traceObj = { traceEvents: cloneDeep(rawTraceData) };
    hierarchy.each((node) => {
        const completeEvent = {
            pid: trace.mainProcess.id,
            tid: trace.mainProcess.mainThread.id,
            ts: node.data.min,
            ph: trace_1.TRACE_EVENT_PHASE_COMPLETE,
            cat: 'blink.user_timing',
            name: node.data.callFrame.functionName,
            args: {
                data: {
                    functionName: node.data.callFrame.functionName,
                    moduleName: modMatcher.findModuleName(node.data.callFrame)
                }
            },
            dur: node.data.max - node.data.min
        };
        traceObj.traceEvents.push(completeEvent);
    });
    fs_extra_1.writeJSONSync(`${filename}.json`, JSON.stringify(traceObj));
}
function methodsFromCategories(categories) {
    return Object.keys(categories).reduce((accum, category) => {
        accum.push(...categories[category]);
        return accum;
    }, []);
}
exports.methodsFromCategories = methodsFromCategories;
function computeMinMax(trace, start = 'navigationStart', end) {
    let min;
    let max;
    if (end) {
        // TODO harden this to find the correct frame
        const startEvent = trace.events.find((e) => e.name === start);
        const endEvent = trace.events.find((e) => e.name === end);
        if (!endEvent) {
            throw new Error(`Could not find "${end}" marker in the trace.`);
        }
        min = startEvent.ts;
        max = endEvent.ts;
    }
    else {
        min = -1;
        max = -1;
    }
    return { min, max };
}
function getRenderingNodes(root) {
    const renderNodes = [];
    root.each((node) => {
        if (render_events_1.isRenderNode(node)) {
            renderNodes.push(node);
        }
    });
    return renderNodes;
}
function getCPUProfile(trace, event) {
    const { min, max } = computeMinMax(trace, 'navigationStart', event);
    return trace.cpuProfile(min, max);
}
//# sourceMappingURL=analyze.js.map