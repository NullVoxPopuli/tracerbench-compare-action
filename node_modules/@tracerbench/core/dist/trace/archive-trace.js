"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleHeaders = exports.getResponseBody = exports.processEntries = exports.processEntriesLoop = exports.recordHARClient = void 0;
const utils_1 = require("./utils");
const debug = require("debug");
// run with DEBUG=* eg.`DEBUG=* tracerbench record-har`
// run with DEBUG=tracerbench:archive-trace eg.`DEBUG=tracerbench:archive-trace tracerbench record-har`
const debugCallback = debug('tracerbench:archive-trace');
const networkRequestStacks = {
    stackA: [],
    stackB: []
};
async function recordHARClient(url, cookies, marker, conditions, headless = false, altBrowserArgs) {
    const archive = {
        log: {
            version: '0.0.0',
            creator: {
                name: 'TracerBench',
                version: '0.0.0'
            },
            entries: []
        }
    };
    const browserArgs = utils_1.getBrowserArgs(altBrowserArgs);
    const browser = await utils_1.createBrowser(browserArgs, headless);
    try {
        const chrome = await utils_1.getTab(browser.connection);
        chrome.on('Network.requestWillBeSent', (params) => {
            debugCallback('Network.requestWillBeSent %o', params);
        });
        chrome.on('Network.responseReceived', (params) => {
            const { statusText, status } = params.response;
            if (params.type === 'Other' ||
                statusText === 'No Content' ||
                status === 204 ||
                status === 206 ||
                (statusText !== 'OK' && status >= 400)) {
                debugCallback('NOT-INCLUDED %o', params);
                return;
            }
            debugCallback('Network.responseReceived %o', params);
            networkRequestStacks.stackA.push(params);
        });
        // enable Network / Page / Runtime
        await Promise.all([
            chrome.send('Page.enable'),
            chrome.send('Network.enable'),
            chrome.send('Runtime.enable')
        ]);
        // clear and disable cache
        await chrome.send('Network.clearBrowserCache');
        // disable cache
        await chrome.send('Network.setCacheDisabled', { cacheDisabled: true });
        await utils_1.emulate(chrome, conditions);
        // set cookies
        await utils_1.setCookies(chrome, cookies);
        // add performance observer script to eval
        await chrome.send('Page.addScriptToEvaluateOnNewDocument', {
            source: `
        self.__TBMarkerPromise = new Promise(resolve => {
          const observer = new PerformanceObserver((list) => {
            if (list.getEntriesByName('${marker}').length > 0) {
              resolve();
            }
        });
        observer.observe({ entryTypes: ["mark", "navigation"] });
        });`
        });
        // navigate to the url
        await chrome.send('Page.navigate', { url });
        // eval
        const evalPromise = chrome.send('Runtime.evaluate', {
            expression: `__TBMarkerPromise`,
            awaitPromise: true
        });
        let timeoutId;
        const timeout = new Promise((reject) => {
            timeoutId = setTimeout(() => {
                clearTimeout(timeoutId);
                reject('Promise timed out after waiting for 20 seconds');
            }, 20000);
        });
        await Promise.race([evalPromise, timeout]).then(() => {
            if (timeoutId) {
                clearTimeout(timeoutId);
            }
            debugCallback('evalPromise resolved with marker %o', marker);
        });
        archive.log.entries = await processEntriesLoop(chrome);
        await Promise.all([
            chrome.send('Network.disable'),
            chrome.send('Runtime.disable')
        ]);
        debugCallback('Network.disable');
        debugCallback('Runtime.disable');
        await chrome.send('Page.close');
        debugCallback('Page.close');
    }
    catch (e) {
        throw new Error(e);
    }
    finally {
        if (browser) {
            await browser.dispose();
            debugCallback('browser.dispose()');
        }
    }
    return archive;
}
exports.recordHARClient = recordHARClient;
async function processEntriesLoop(chrome) {
    debugCallback('processEntriesLoop() %o', `${networkRequestStacks.stackA.length} entries`);
    let networkEntries = [];
    // empty A into B
    networkRequestStacks.stackB = networkRequestStacks.stackA;
    networkRequestStacks.stackA = [];
    // process B and empty
    networkEntries = await processEntries(networkRequestStacks.stackB, chrome);
    networkRequestStacks.stackB = [];
    // check A for new entries
    // if empty return
    if (networkRequestStacks.stackA.length > 0) {
        debugCallback('processEntriesLoop() %o', `${networkRequestStacks.stackA.length} entries`);
        networkEntries = networkEntries.concat(await processEntriesLoop(chrome));
    }
    return networkEntries;
}
exports.processEntriesLoop = processEntriesLoop;
async function processEntries(networkRequests, chrome) {
    debugCallback('processEntries()');
    const entries = [];
    for (let i = 0; i < networkRequests.length; i++) {
        debugCallback('processEntries.entry %o', networkRequests[i].response.url);
        const { requestId, response } = networkRequests[i];
        const body = await getResponseBody(requestId, chrome);
        const { url, requestHeaders, status, statusText, headers, mimeType, protocol } = response;
        const entry = {
            time: 0,
            cache: {},
            timings: {
                send: 0,
                wait: 0,
                receive: 0
            },
            serverIPAddress: response.remoteIPAddress || '',
            startedDateTime: new Date().toISOString(),
            request: {
                url,
                method: handleHeaders(requestHeaders)[0].value || '',
                httpVersion: protocol || '',
                cookies: [],
                headers: handleHeaders(requestHeaders),
                queryString: [],
                headersSize: 0,
                bodySize: 0
            },
            response: {
                status,
                statusText,
                httpVersion: protocol || '',
                cookies: [],
                headers: handleHeaders(headers),
                redirectURL: '',
                headersSize: 0,
                bodySize: 0,
                content: {
                    text: body,
                    size: 0,
                    mimeType
                }
            }
        };
        entries.push(entry);
    }
    return entries;
}
exports.processEntries = processEntries;
async function getResponseBody(requestId, chrome) {
    try {
        const { body } = await chrome.send('Network.getResponseBody', {
            requestId
        });
        return body;
    }
    catch (error) {
        return '';
    }
}
exports.getResponseBody = getResponseBody;
function handleHeaders(headers) {
    if (!headers) {
        return [{ name: '', value: '' }];
    }
    return Object.entries(headers).map((e) => {
        return { name: e[0], value: e[1] };
    });
}
exports.handleHeaders = handleHeaders;
//# sourceMappingURL=archive-trace.js.map