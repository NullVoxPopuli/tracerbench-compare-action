"use strict";
/* eslint-disable @typescript-eslint/no-non-null-assertion */
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const core_1 = require("@tracerbench/core");
const fs = require("fs-extra");
const path = require("path");
const command_config_1 = require("../../command-config");
const default_flag_args_1 = require("../../command-config/default-flag-args");
const tb_config_1 = require("../../command-config/tb-config");
const device_settings_1 = require("../../helpers/device-settings");
const flags_1 = require("../../helpers/flags");
const utils_1 = require("../../helpers/utils");
const analyze_1 = require("./analyze");
const report_1 = require("./report");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const archiver = require("archiver");
class Compare extends command_config_1.TBBaseCommand {
    constructor(argv, config) {
        super(argv, config);
        this.parsedConfig = default_flag_args_1.defaultFlagArgs;
        this.analyzedJSONString = "";
        const { flags } = this.parse(Compare);
        this.explicitFlags = argv;
        this.compareFlags = flags;
    }
    // instantiated before this.run()
    async init() {
        const { flags } = this.parse(Compare);
        this.parsedConfig = command_config_1.getConfig(flags.config, flags, this.explicitFlags);
        this.compareFlags = flags;
        await this.parseFlags();
    }
    async run() {
        const { hideAnalysis } = this.compareFlags;
        const [controlSettings, experimentSettings,] = this.generateControlExperimentServerConfig();
        // this should be directly above the instantiation of the InitialRenderBenchmarks
        if (this.parsedConfig.debug) {
            Object.entries(this.parsedConfig).forEach(([key, value]) => {
                if (value) {
                    this.log(`${key}: ${JSON.stringify(value)}`);
                }
            });
        }
        const benchmarks = {
            control: core_1.createTraceNavigationBenchmark(...controlSettings),
            experiment: core_1.createTraceNavigationBenchmark(...experimentSettings),
        };
        const sampleTimeout = this.parsedConfig.sampleTimeout;
        const startTime = utils_1.timestamp();
        const results = (await core_1.run([benchmarks.control, benchmarks.experiment], this.parsedConfig.fidelity, (elasped, completed, remaining, group, iteration) => {
            if (completed > 0) {
                const average = elasped / completed;
                const remainingSecs = Math.round((remaining * average) / 1000);
                const remainingTime = utils_1.secondsToTime(remainingSecs);
                console.log("%s: %s %s remaining", group.padStart(15), iteration.toString().padStart(2), `${remainingTime}`.padStart(10));
            }
            else {
                console.log("%s: %s", group.padStart(15), iteration.toString().padStart(2));
            }
        }, {
            sampleTimeoutMs: sampleTimeout && sampleTimeout * 1000,
        })).map(({ group, samples }) => {
            const meta = samples.length > 0 ? samples[0].metadata : {};
            return {
                group,
                set: group,
                samples,
                meta,
            };
        });
        const endTime = utils_1.timestamp();
        if (!results[0].samples[0]) {
            this.error(`Could not sample from provided urls\nCONTROL: ${this.parsedConfig.controlURL}\nEXPERIMENT: ${this.parsedConfig.experimentURL}.`);
        }
        const resultJSONPath = `${this.parsedConfig.tbResultsFolder}/compare.json`;
        fs.writeFileSync(resultJSONPath, JSON.stringify(results));
        const tracesDir = `${this.parsedConfig.tbResultsFolder}/traces`;
        const zipOutput = fs.createWriteStream(`${this.parsedConfig.tbResultsFolder}/traces.zip`);
        const archive = archiver("zip", {
            zlib: { level: 9 },
        });
        archive.directory(tracesDir, "traces");
        archive.pipe(zipOutput);
        archive.finalize();
        const duration = utils_1.secondsToTime(utils_1.durationInSec(endTime, startTime));
        const message = `${utils_1.chalkScheme.blackBgGreen(`    ${utils_1.chalkScheme.white("SUCCESS")}    `)} ${this.parsedConfig.fidelity} test samples took ${duration}`;
        this.log(`\n${message}`);
        if (!hideAnalysis) {
            this.analyzedJSONString = await analyze_1.default.run([
                resultJSONPath,
                "--fidelity",
                `${this.parsedConfig.fidelity}`,
                "--regressionThreshold",
                `${this.parsedConfig.regressionThreshold}`,
                "--isCIEnv",
                `${this.parsedConfig.isCIEnv}`,
            ]);
            fs.writeFileSync(`${this.parsedConfig.tbResultsFolder}/report.json`, this.analyzedJSONString);
        }
        // if we want to run the CompareReport without calling a separate command
        if (this.parsedConfig.report) {
            await report_1.default.run([
                "--tbResultsFolder",
                `${this.parsedConfig.tbResultsFolder}`,
                "--config",
                `${this.parsedConfig.config}`,
                "--isCIEnv",
                `${this.parsedConfig.isCIEnv}`,
            ]);
        }
        // with debug flag output three files
        // on config specifics
        if (this.parsedConfig.debug) {
            fs.writeFileSync(`${this.parsedConfig.tbResultsFolder}/server-control-settings.json`, JSON.stringify(Object.assign(controlSettings), null, 2));
            fs.writeFileSync(`${this.parsedConfig.tbResultsFolder}/server-experiment-settings.json`, JSON.stringify(Object.assign(experimentSettings), null, 2));
            fs.writeFileSync(`${this.parsedConfig.tbResultsFolder}/compare-flags-settings.json`, JSON.stringify(Object.assign(this.parsedConfig), null, 2));
        }
        return this.analyzedJSONString;
    }
    async parseFlags() {
        const { tbResultsFolder, fidelity, markers, regressionThreshold, headless, controlURL, experimentURL, } = this.parsedConfig;
        // modifies properties of flags that were not set
        // during flag.parse(). these are intentionally
        // not deconstructed as to maintain the mutable
        // flags object state
        if (typeof fidelity === "string") {
            this.compareFlags.fidelity = parseInt(default_flag_args_1.fidelityLookup[fidelity], 10);
        }
        if (typeof markers === "string") {
            this.parsedConfig.markers = utils_1.parseMarkers(markers);
        }
        if (typeof regressionThreshold === "string") {
            this.parsedConfig.regressionThreshold = parseInt(regressionThreshold, 10);
        }
        if (typeof controlURL === undefined) {
            this.error("controlURL is required either in the tbconfig.json or as cli flag");
        }
        if (typeof experimentURL === undefined) {
            this.error("experimentURL is required either in the tbconfig.json or as cli flag");
        }
        // if headless flag is true include the headless flags
        if (headless) {
            this.parsedConfig.browserArgs = this.compareFlags.browserArgs.concat(default_flag_args_1.headlessFlags);
        }
        // if the folder for the tracerbench results file
        // does not exist then create it
        fs.mkdirpSync(path.join(tbResultsFolder, "traces"));
    }
    /**
     * Final result of the configs are in the following order:
     *
     * controlConfigs = tbconfig:controlBenchmarkEnvironment > command line > tbconfig > default
     * experimentConfigs = tbconfig:experimentBenchmarkEnvironment > command line > tbconfig > default
     *
     * This functions handles the tsconfig:** part since it is assumed that parent function that passed input "flags"
     * would've handled "command line > tbconfig > default"
     *
     * @param this.parsedConfig - Object containing configs parsed from the Command class
     */
    generateControlExperimentServerConfig() {
        const stdio = this.parsedConfig.debug ? "inherit" : "ignore";
        const controlBrowser = {
            stdio,
            additionalArguments: this.compareFlags.browserArgs,
        };
        const experimentBrowser = {
            stdio,
            additionalArguments: this.compareFlags.browserArgs,
        };
        // config for the browsers to leverage socks proxy
        if (this.parsedConfig.socksPorts) {
            if (controlBrowser.additionalArguments) {
                controlBrowser.additionalArguments = controlBrowser.additionalArguments.concat([`--proxy-server=socks5://0.0.0.0:${this.parsedConfig.socksPorts[0]}`]);
            }
            if (experimentBrowser.additionalArguments) {
                experimentBrowser.additionalArguments = experimentBrowser.additionalArguments.concat([`--proxy-server=socks5://0.0.0.0:${this.parsedConfig.socksPorts[1]}`]);
            }
        }
        const controlNetwork = utils_1.checkEnvironmentSpecificOverride("network", this.compareFlags, tb_config_1.CONTROL_ENV_OVERRIDE_ATTR, this.parsedConfig);
        const controlEmulateDevice = utils_1.checkEnvironmentSpecificOverride("emulateDevice", this.compareFlags, tb_config_1.CONTROL_ENV_OVERRIDE_ATTR, this.parsedConfig);
        const controlEmulateDeviceOrientation = utils_1.checkEnvironmentSpecificOverride("emulateDeviceOrientation", this.compareFlags, tb_config_1.CONTROL_ENV_OVERRIDE_ATTR, this.parsedConfig);
        const experimentNetwork = utils_1.checkEnvironmentSpecificOverride("network", this.compareFlags, tb_config_1.EXPERIMENT_ENV_OVERRIDE_ATTR, this.parsedConfig);
        const experimentEmulateDevice = utils_1.checkEnvironmentSpecificOverride("emulateDevice", this.compareFlags, tb_config_1.EXPERIMENT_ENV_OVERRIDE_ATTR, this.parsedConfig);
        const experimentEmulateDeviceOrientation = utils_1.checkEnvironmentSpecificOverride("emulateDeviceOrientation", this.compareFlags, tb_config_1.EXPERIMENT_ENV_OVERRIDE_ATTR, this.parsedConfig);
        const controlDeviceSettings = controlEmulateDevice
            ? device_settings_1.getEmulateDeviceSettingForKeyAndOrientation(controlEmulateDevice, controlEmulateDeviceOrientation)
            : {};
        const controlSettings = [
            "control",
            this.compareFlags.controlURL,
            this.compareFlags.markers,
            {
                spawnOptions: controlBrowser,
                pageSetupOptions: Object.assign(Object.assign({ cpuThrottlingRate: utils_1.checkEnvironmentSpecificOverride("cpuThrottleRate", this.compareFlags, tb_config_1.CONTROL_ENV_OVERRIDE_ATTR, this.parsedConfig) }, controlDeviceSettings), { emulateNetworkConditions: controlNetwork
                        ? core_1.networkConditions[controlNetwork]
                        : this.compareFlags.network }),
                traceOptions: {
                    captureV8RuntimeStats: this.compareFlags.runtimeStats,
                    saveTraceAs: (group, i) => `${this.compareFlags.tbResultsFolder}/traces/${group}${i}.json`,
                },
            },
        ];
        const experimentDeviceSettings = experimentEmulateDevice
            ? device_settings_1.getEmulateDeviceSettingForKeyAndOrientation(experimentEmulateDevice, experimentEmulateDeviceOrientation)
            : {};
        const experimentSettings = [
            "experiment",
            this.compareFlags.experimentURL,
            this.compareFlags.markers,
            {
                spawnOptions: experimentBrowser,
                pageSetupOptions: Object.assign(Object.assign({ cpuThrottlingRate: utils_1.checkEnvironmentSpecificOverride("cpuThrottleRate", this.compareFlags, tb_config_1.EXPERIMENT_ENV_OVERRIDE_ATTR, this.parsedConfig) }, experimentDeviceSettings), { emulateNetworkConditions: experimentNetwork
                        ? core_1.networkConditions[experimentNetwork]
                        : this.compareFlags.network }),
                traceOptions: {
                    captureV8RuntimeStats: this.compareFlags.runtimeStats,
                    saveTraceAs: (group, i) => `${this.compareFlags.tbResultsFolder}/traces/${group}${i}.json`,
                },
            },
        ];
        return [controlSettings, experimentSettings];
    }
}
exports.default = Compare;
Compare.description = "Compare the performance delta between an experiment and control";
Compare.flags = {
    hideAnalysis: command_1.flags.boolean({
        default: false,
        description: "Hide the the analysis output in terminal",
    }),
    browserArgs: flags_1.browserArgs({ required: true }),
    cpuThrottleRate: flags_1.cpuThrottleRate({ required: true }),
    fidelity: flags_1.fidelity({ required: true }),
    markers: flags_1.markers({ required: true }),
    network: flags_1.network({ required: true }),
    tbResultsFolder: flags_1.tbResultsFolder({ required: true }),
    controlURL: flags_1.controlURL({ required: false }),
    experimentURL: flags_1.experimentURL({ required: false }),
    emulateDevice: flags_1.emulateDevice(),
    emulateDeviceOrientation: flags_1.emulateDeviceOrientation(),
    socksPorts: flags_1.socksPorts(),
    regressionThreshold: flags_1.regressionThreshold(),
    sampleTimeout: flags_1.sampleTimeout(),
    config: flags_1.config(),
    runtimeStats: flags_1.runtimeStats,
    report: flags_1.report,
    debug: flags_1.debug,
    headless: flags_1.headless,
    isCIEnv: flags_1.isCIEnv(),
};
//# sourceMappingURL=index.js.map