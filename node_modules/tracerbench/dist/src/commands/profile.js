"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/no-explicit-any */
const core_1 = require("@tracerbench/core");
const fs_extra_1 = require("fs-extra");
const listr = require("listr");
const path_1 = require("path");
const command_config_1 = require("../command-config");
const args_1 = require("../helpers/args");
const flags_1 = require("../helpers/flags");
const utils_1 = require("../helpers/utils");
class Profile extends command_config_1.TBBaseCommand {
    constructor() {
        super(...arguments);
        this.trace = [];
    }
    async run() {
        const { flags, args } = this.parse(Profile);
        const { cpuThrottleRate, cookiespath, tbResultsFolder, network, url, } = flags;
        const { harpath } = args;
        const cookies = [
            {
                name: "",
                value: "",
                domain: "",
                path: "",
            },
        ];
        const conditions = {
            network: network ? network : "none",
            cpu: cpuThrottleRate ? cpuThrottleRate : 1,
        };
        const tasks = new listr([
            {
                title: "Reading cookies json",
                task: async (ctx) => {
                    // read cookies json file from path and set to context
                    ctx.cookies = cookiespath.length
                        ? await fs_extra_1.readJson(path_1.resolve(cookiespath))
                        : cookies;
                },
            },
            {
                title: "Preparing results folder",
                task: () => {
                    // if the folder for the tracerbench results file
                    // does not exist then create it
                    try {
                        if (!fs_extra_1.existsSync(tbResultsFolder)) {
                            fs_extra_1.mkdirSync(tbResultsFolder);
                        }
                    }
                    catch (error) {
                        this.error(error);
                    }
                },
            },
            {
                title: "Validating & Cloning HAR file",
                task: async (ctx) => {
                    // validate har and clone it to trace.json which will be mutated
                    ctx.harJSON = await fs_extra_1.readJson(path_1.resolve(harpath));
                    ctx.traceJSONPath = path_1.join(tbResultsFolder, "trace.json");
                    fs_extra_1.writeFileSync(ctx.traceJSONPath, JSON.stringify(ctx.harJSON, null, 2));
                    // if no url get url from har otherwise set with cmd url
                    ctx.url = url.length ? url : getURLFromHAR(ctx);
                    function getURLFromHAR(ctx) {
                        try {
                            const url = ctx.harJSON.log.entries[0].request.url;
                            return url;
                        }
                        catch (error) {
                            throw new Error(`${error}. Could not extract the URL from the HAR. Explicitly pass via "--url" flag and rerun.`);
                        }
                    }
                },
            },
            {
                title: "Recording the live trace",
                task: async (ctx) => {
                    const { cookies, url } = ctx;
                    try {
                        // run the liveTrace
                        const { traceEvents } = await core_1.liveTrace(url, tbResultsFolder, cookies, conditions);
                        ctx.traceEvents = traceEvents;
                    }
                    catch (error) {
                        this.error(`${error}`);
                    }
                },
            },
            {
                title: "Setting trace events",
                task: async (ctx) => {
                    const { traceEvents } = ctx;
                    // mutates this.trace
                    try {
                        this.trace = utils_1.setTraceEvents(traceEvents);
                    }
                    catch (error) {
                        this.error(`${error}`);
                    }
                },
            },
        ]);
        await tasks
            .run()
            .catch((error) => {
            this.error(`${error}`);
        })
            .then(async (ctx) => {
            // log js-eval-time
            this.logJSEvalTime();
            // log css-parse
            this.logCSSEvalTime();
            // log user timings
            await this.markerTimings(ctx.traceJSONPath, ctx.url);
        });
    }
    logJSEvalTime() {
        let totalJSDuration = 0;
        const jsEvalLogs = [];
        this.trace
            .filter((event) => event.name === "EvaluateScript")
            .filter((event) => event.args.data.url)
            .forEach((event) => {
            const url = event.args.data.url;
            const durationInMs = event.dur / 1000;
            totalJSDuration += durationInMs;
            jsEvalLogs.push({
                totalDuration: totalJSDuration,
                duration: durationInMs,
                title: url,
            });
        });
        utils_1.logHeading(`JS Evaluation :: Total Duration ${totalJSDuration} ms`);
        // log js-eval-time
        jsEvalLogs
            .sort((a, b) => {
            return a.duration - b.duration;
        })
            .forEach((log) => {
            this.log(utils_1.logBar(log));
        });
    }
    logCSSEvalTime() {
        let totalCSSDuration = 0;
        const cssEvalLogs = [];
        this.trace
            .filter((event) => event.name === "ParseAuthorStyleSheet")
            .filter((event) => event.args.data.styleSheetUrl)
            .forEach((event) => {
            const url = event.args.data.styleSheetUrl;
            const durationInMs = event.dur / 1000;
            totalCSSDuration += durationInMs;
            cssEvalLogs.push({
                totalDuration: totalCSSDuration,
                duration: durationInMs,
                title: url,
            });
        });
        utils_1.logHeading(`CSS Evaluation :: Total Duration ${totalCSSDuration} ms`);
        // log css-parse-time
        cssEvalLogs
            .sort((a, b) => {
            return a.duration - b.duration;
        })
            .forEach((log) => {
            this.log(utils_1.logBar(log));
        });
    }
    // tracerbench marker-timings cmd moved here
    async markerTimings(traceJSONPath, url) {
        let frame;
        let startTime = -1;
        let rawTraceData = null;
        let customTrace;
        const markerLogs = [];
        if (!url) {
            this.error(`Could not extract the URL from the HAR. Explicitly pass via "--url" flag and rerun.`);
        }
        try {
            rawTraceData = await fs_extra_1.readJson(path_1.resolve(traceJSONPath));
        }
        catch (e) {
            this.error(e);
        }
        try {
            customTrace = utils_1.setTraceEvents(rawTraceData);
        }
        catch (e) {
            this.error(e);
        }
        if (url.startsWith("http")) {
            frame = utils_1.findFrame(customTrace, url);
        }
        else {
            frame = url;
        }
        if (!frame) {
            this.error(`Could not extract frame from trace. Explicitly opt-out of usertimings via "--usertimings" boolean flag and rerun.`);
        }
        customTrace
            .filter((event) => utils_1.isMark(event) || utils_1.isCommitLoad(event))
            .sort(utils_1.byTime)
            .forEach((event) => {
            if (utils_1.isFrameNavigationStart(frame, event, url)) {
                startTime = event.ts;
                markerLogs.push(this.buildMarkerLogs(event, startTime));
            }
            else if (utils_1.isFrameMark(frame, event) &&
                event.name !== "navigationStart") {
                if (startTime === -1) {
                    return;
                }
                markerLogs.push(this.buildMarkerLogs(event, startTime));
            }
        });
        this.logMarkerTimings(markerLogs);
    }
    buildMarkerLogs(event, startTime) {
        return {
            name: event.name,
            sentanceCaseName: utils_1.convertToSentCase(event.name),
            duration: utils_1.formatToDuration(event.ts, startTime),
            startTime,
            bar: "",
        };
    }
    logMarkerTimings(markerLogs) {
        const totalDuration = markerLogs[markerLogs.length - 1].duration;
        utils_1.logHeading(`Marker Timings :: Total Duration ${totalDuration} ms`);
        markerLogs.forEach((log) => {
            this.log(utils_1.logBar({
                totalDuration,
                duration: log.duration,
                title: log.sentanceCaseName,
            }));
        });
    }
}
exports.default = Profile;
// include backwards compat to trace cmd
Profile.aliases = ["trace"];
Profile.description = `Parses a CPU profile with asset and marker timings.`;
Profile.args = [args_1.harpath];
Profile.flags = {
    cpuThrottleRate: flags_1.cpuThrottleRate({ required: true }),
    tbResultsFolder: flags_1.tbResultsFolder({ required: true }),
    network: flags_1.network(),
    url: flags_1.url({ required: true }),
    cookiespath: flags_1.cookiespath({ required: true }),
};
//# sourceMappingURL=profile.js.map