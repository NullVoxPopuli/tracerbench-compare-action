"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/no-explicit-any */
const stats_1 = require("@tracerbench/stats");
const fs_extra_1 = require("fs-extra");
const Handlebars = require("handlebars");
const path = require("path");
const default_flag_args_1 = require("../command-config/default-flag-args");
const utils_1 = require("./utils");
exports.PAGE_LOAD_TIME = "duration";
const CHART_CSS_PATH = path.join(__dirname, "../static/chart-bootstrap.css");
const CHART_JS_PATH = path.join(__dirname, "../static/chartjs-2.9.3-chart.min.js");
const REPORT_PATH = path.join(__dirname, "../static/report-template.hbs");
const PHASE_DETAIL_PARTIAL = path.join(__dirname, "../static/phase-detail-partial.hbs");
const PHASE_CHART_JS_PARTIAL = path.join(__dirname, "../static/phase-chart-js-partial.hbs");
const CHART_CSS = fs_extra_1.readFileSync(CHART_CSS_PATH, "utf8");
const CHART_JS = fs_extra_1.readFileSync(CHART_JS_PATH, "utf8");
const PHASE_DETAIL_TEMPLATE_RAW = fs_extra_1.readFileSync(PHASE_DETAIL_PARTIAL, "utf8");
const PHASE_CHART_JS_TEMPLATE_RAW = fs_extra_1.readFileSync(PHASE_CHART_JS_PARTIAL, "utf8");
let REPORT_TEMPLATE_RAW = fs_extra_1.readFileSync(REPORT_PATH, "utf8");
REPORT_TEMPLATE_RAW = REPORT_TEMPLATE_RAW.toString()
    .replace("{{!-- TRACERBENCH-CHART-BOOTSTRAP.CSS --}}", `<style>${CHART_CSS}</style>`)
    .replace("{{!-- TRACERBENCH-CHART-JS --}}", `<script>${CHART_JS}</script>`);
Handlebars.registerPartial("phaseChartJSSection", PHASE_CHART_JS_TEMPLATE_RAW);
Handlebars.registerPartial("phaseDetailSection", PHASE_DETAIL_TEMPLATE_RAW);
/**
 * Camel case helper
 */
Handlebars.registerHelper("toCamel", (val) => {
    return val.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
});
/**
 * Negative means slower
 */
Handlebars.registerHelper("isFaster", (analysis) => {
    return analysis.hlDiff > 0;
});
/**
 * Absolute number helper
 */
Handlebars.registerHelper("abs", (num) => {
    return Math.abs(num);
});
/**
 * Sort the given numbers by their absolute values
 */
Handlebars.registerHelper("absSort", (num1, num2, position) => {
    const sorted = [Math.abs(num1), Math.abs(num2)];
    sorted.sort((a, b) => a - b);
    return sorted[position];
});
/**
 * Extract the phases and page load time latency into sorted buckets by phase
 *
 * @param samples - Array of "sample" objects
 * @param valueGen - Calls this function to extract the value from the phase. A
 *   "phase" is passed containing duration and start
 */
function bucketPhaseValues(samples, valueGen = (a) => a.duration) {
    const buckets = { [exports.PAGE_LOAD_TIME]: [] };
    samples.forEach((sample) => {
        buckets[exports.PAGE_LOAD_TIME].push(sample[exports.PAGE_LOAD_TIME]);
        sample.phases.forEach((phaseData) => {
            const bucket = buckets[phaseData.phase] || [];
            bucket.push(valueGen(phaseData));
            buckets[phaseData.phase] = bucket;
        });
    });
    return buckets;
}
exports.bucketPhaseValues = bucketPhaseValues;
/**
 * Override the default server and plot title attributes
 *
 * @param tbConfig - Concerned only about the "servers" and "plotTitle"
 *   attribute
 * @param version - Browser version
 */
function resolveTitles(tbConfig, version) {
    const reportTitles = {
        servers: [{ name: "Control" }, { name: "Experiment" }],
        plotTitle: default_flag_args_1.defaultFlagArgs.plotTitle,
        browserVersion: version,
    };
    if (tbConfig.servers) {
        reportTitles.servers = tbConfig.servers.map((titleConfig, idx) => {
            if (idx === 0) {
                return { name: `Control: ${titleConfig.name}` };
            }
            else {
                return { name: `Experiment: ${titleConfig.name}` };
            }
        });
    }
    if (tbConfig.plotTitle) {
        reportTitles.plotTitle = tbConfig.plotTitle;
    }
    return reportTitles;
}
exports.resolveTitles = resolveTitles;
/**
 * Generate the HTML render data for the cumulative chart. Ensure to convert to
 * milliseconds for presentation
 *
 * @param controlData - Samples of the benchmark of control server
 * @param experimentData - Samples of the benchmark experiment server
 */
function buildCumulativeChartData(controlData, experimentData) {
    const cumulativeValueFunc = (a) => utils_1.convertMicrosecondsToMS(a.start + a.duration);
    const valuesByPhaseControl = bucketPhaseValues(controlData.samples, cumulativeValueFunc);
    const valuesByPhaseExperiment = bucketPhaseValues(experimentData.samples, cumulativeValueFunc);
    const phases = Object.keys(valuesByPhaseControl).filter((k) => k !== exports.PAGE_LOAD_TIME);
    return {
        categories: JSON.stringify(phases),
        controlData: JSON.stringify(phases.map((k) => valuesByPhaseControl[k])),
        experimentData: JSON.stringify(phases.map((k) => valuesByPhaseExperiment[k])),
    };
}
exports.buildCumulativeChartData = buildCumulativeChartData;
/**
 * Call the stats helper functions to generate the confidence interval and
 * Hodgesâ€“Lehmann estimator. Format the data into HTMLSectionRenderData
 * structure.
 *
 * @param controlValues - Values for the control for the phase
 * @param experimentValues - Values for the experiment for the phase
 * @param phaseName - Name of the phase the values represent
 */
function formatPhaseData(controlValues, experimentValues, phaseName) {
    const stats = new stats_1.Stats({
        control: controlValues,
        experiment: experimentValues,
        name: "output",
    });
    const isNotSignificant = (stats.confidenceInterval.min < 0 && 0 < stats.confidenceInterval.max) ||
        (stats.confidenceInterval.min > 0 && 0 > stats.confidenceInterval.max) ||
        (stats.confidenceInterval.min === 0 && stats.confidenceInterval.max === 0);
    return {
        phase: phaseName,
        identifierHash: phaseName,
        isSignificant: !isNotSignificant,
        sampleCount: stats.sampleCount.control,
        ciMin: stats.confidenceInterval.min,
        ciMax: stats.confidenceInterval.max,
        hlDiff: stats.estimator,
        servers: undefined,
        controlFormatedSamples: JSON.stringify({
            min: stats.sevenFigureSummary.control.min,
            q1: stats.sevenFigureSummary.control[25],
            median: stats.sevenFigureSummary.control[50],
            q3: stats.sevenFigureSummary.control[75],
            max: stats.sevenFigureSummary.control.max,
            outliers: stats.outliers.control.outliers,
            samplesMS: stats.controlMS,
        }),
        experimentFormatedSamples: JSON.stringify({
            min: stats.sevenFigureSummary.experiment.min,
            q1: stats.sevenFigureSummary.experiment[25],
            median: stats.sevenFigureSummary.experiment[50],
            q3: stats.sevenFigureSummary.experiment[75],
            max: stats.sevenFigureSummary.experiment.max,
            outliers: stats.outliers.experiment.outliers,
            samplesMS: stats.experimentMS,
        }),
    };
}
exports.formatPhaseData = formatPhaseData;
/**
 * Prioritize the phase that has the largest difference in regression first.
 */
function phaseSorter(a, b) {
    const A_ON_TOP = -1;
    const B_ON_TOP = 1;
    if (a.isSignificant) {
        if (!b.isSignificant) {
            return A_ON_TOP;
        }
        else {
            // If both are significant prefer slowest one
            return a.hlDiff - b.hlDiff;
        }
    }
    if (b.isSignificant) {
        if (!a.isSignificant) {
            return B_ON_TOP;
        }
    }
    return 0;
}
exports.phaseSorter = phaseSorter;
function generateDataForHTML(controlData, experimentData, reportTitles) {
    const valuesByPhaseControl = bucketPhaseValues(controlData.samples);
    const valuesByPhaseExperiment = bucketPhaseValues(experimentData.samples);
    const subPhases = Object.keys(valuesByPhaseControl).filter((k) => k !== exports.PAGE_LOAD_TIME);
    const durationSection = formatPhaseData(valuesByPhaseControl[exports.PAGE_LOAD_TIME], valuesByPhaseExperiment[exports.PAGE_LOAD_TIME], exports.PAGE_LOAD_TIME);
    const subPhaseSections = subPhases.map((phase) => {
        const controlValues = valuesByPhaseControl[phase];
        const experimentValues = valuesByPhaseExperiment[phase];
        const renderDataForPhase = formatPhaseData(controlValues, experimentValues, phase);
        renderDataForPhase.servers = reportTitles.servers;
        return renderDataForPhase;
    });
    durationSection.servers = reportTitles.servers;
    return { durationSection, subPhaseSections };
}
exports.generateDataForHTML = generateDataForHTML;
function createConsumableHTML(controlData, experimentData, tbConfig) {
    const reportTitles = resolveTitles(tbConfig, controlData.meta.browserVersion);
    const { durationSection, subPhaseSections } = generateDataForHTML(controlData, experimentData, reportTitles);
    const template = Handlebars.compile(REPORT_TEMPLATE_RAW);
    return template({
        cumulativeChartData: buildCumulativeChartData(controlData, experimentData),
        durationSection,
        reportTitles,
        subPhaseSections,
        configsSJSONString: JSON.stringify(tbConfig, null, 4),
        sectionFormattedDataJson: JSON.stringify(subPhaseSections),
    });
}
exports.default = createConsumableHTML;
//# sourceMappingURL=create-consumable-html.js.map