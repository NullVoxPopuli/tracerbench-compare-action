"use strict";
/* eslint-disable @typescript-eslint/explicit-function-return-type */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint:disable:no-console*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.durationInSec = exports.timestamp = exports.logBar = exports.logHeading = exports.convertToSentCase = exports.chalkScheme = exports.toNearestHundreth = exports.convertToTypable = exports.fillArray = exports.parseMarkers = exports.findFrame = exports.byTime = exports.isCommitLoad = exports.isFrameNavigationStart = exports.isDocLoaderURL = exports.isFrameMark = exports.isMark = exports.formatToDuration = exports.setTraceEvents = exports.convertMSToMicroseconds = exports.convertMicrosecondsToMS = exports.mergeLeft = exports.checkEnvironmentSpecificOverride = void 0;
const chalk = require("chalk");
const logSymbols = require("log-symbols");
/**
 * Handles checking if there is a specific override for the attributeName in the tbConfigs for the given overrideObjectName.
 * Defaults to whatever is in the flags object if there is no override.
 *
 * @param attributeName - Attribute name to check if there is an override in overrideObjectName from tbConfig
 * @param flags - Object containing configs parsed from the Command class
 * @param overrideObjectName - Either "controlBenchmarkEnvironment" or "experimentBenchmarkEnvironment"
 * @param tbConfig - This refers to the parsed JSON from the config file if it exists
 */
// eslint-disable-next-line @typescript-eslint/explicit-function-return-type
function checkEnvironmentSpecificOverride(attributeName, flags, overrideObjectName, tbConfig) {
    if (!tbConfig || !tbConfig[overrideObjectName]) {
        return flags[attributeName];
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const environmentSpecificConfigs = tbConfig[overrideObjectName];
    if (!environmentSpecificConfigs[attributeName]) {
        return flags[attributeName];
    }
    return environmentSpecificConfigs[attributeName];
}
exports.checkEnvironmentSpecificOverride = checkEnvironmentSpecificOverride;
/**
 * Merge the contents of the right object into the left. Simply replace numbers, strings, arrays
 * and recursively call this function with objects.
 *
 * Note that typeof null == 'object'
 *
 * @param left - Destination object
 * @param right - Content of this object takes precedence
 */
function mergeLeft(left, right) {
    Object.keys(right).forEach((key) => {
        const leftValue = left[key];
        const rightValue = left[key];
        const matchingObjectType = typeof leftValue === "object" && typeof rightValue === "object";
        const isOneArray = Array.isArray(leftValue) || Array.isArray(rightValue);
        if (matchingObjectType && (left[key] || right[key]) && !isOneArray) {
            mergeLeft(left[key], right[key]);
        }
        else {
            left[key] = right[key];
        }
    });
    return left;
}
exports.mergeLeft = mergeLeft;
function convertMicrosecondsToMS(ms) {
    ms = typeof ms === "string" ? parseInt(ms, 10) : ms;
    return Math.floor(ms * 100) / 100000;
}
exports.convertMicrosecondsToMS = convertMicrosecondsToMS;
function convertMSToMicroseconds(ms) {
    ms = typeof ms === "string" ? parseInt(ms, 10) : ms;
    return Math.floor(ms * 1000);
}
exports.convertMSToMicroseconds = convertMSToMicroseconds;
function setTraceEvents(file) {
    return !Array.isArray(file) ? file.traceEvents : file;
}
exports.setTraceEvents = setTraceEvents;
function formatToDuration(ts, start) {
    return toNearestHundreth((ts - start) / 1000);
}
exports.formatToDuration = formatToDuration;
function isMark(event) {
    return event.ph === "R" /* TRACE_EVENT_PHASE_MARK */;
}
exports.isMark = isMark;
function isFrameMark(frame, event) {
    return (event.ph === "R" /* TRACE_EVENT_PHASE_MARK */ &&
        event.args !== "__stripped__" /* STRIPPED */ &&
        event.args.frame === frame);
}
exports.isFrameMark = isFrameMark;
function isDocLoaderURL(event, url) {
    try {
        if (event.args === "__stripped__" /* STRIPPED */)
            return false;
        if (event.args.data.documentLoaderURL === url) {
            return true;
        }
        return false;
    }
    catch (e) {
        return false;
    }
}
exports.isDocLoaderURL = isDocLoaderURL;
function isFrameNavigationStart(frame, event, url) {
    return (isFrameMark(frame, event) &&
        event.name === "navigationStart" &&
        isDocLoaderURL(event, url));
}
exports.isFrameNavigationStart = isFrameNavigationStart;
function isCommitLoad(event) {
    return (event.ph === "X" /* TRACE_EVENT_PHASE_COMPLETE */ &&
        event.name === "CommitLoad" &&
        event.args !== "__stripped__" /* STRIPPED */ &&
        event.args.data !== undefined &&
        event.args.data.isMainFrame);
}
exports.isCommitLoad = isCommitLoad;
function byTime(a, b) {
    return a.ts - b.ts;
}
exports.byTime = byTime;
function findFrame(events, url) {
    const event = events
        .filter(isCommitLoad)
        .find((e) => e.args.data.url.startsWith(url));
    if (event) {
        return event.args.data.frame;
    }
    return "";
}
exports.findFrame = findFrame;
function parseMarkers(m) {
    const a = [];
    if (typeof m === "string") {
        m = m.split(",");
    }
    for (let i = 1; i < m.length; i++) {
        a.push({
            start: m[i - 1],
            label: m[i],
        });
    }
    a.push({
        start: m[m.length - 1],
        label: "paint",
    });
    return a;
}
exports.parseMarkers = parseMarkers;
function fillArray(arrLngth, incr = 1, strt = 0) {
    const a = [];
    while (a.length < arrLngth) {
        if (a.length < 1) {
            a.push(strt);
        }
        a.push(strt + incr);
        strt = strt + incr;
    }
    return a;
}
exports.fillArray = fillArray;
/**
 * "name" is expected to be a titlecased string. We want something the user can type easily so the passed string
 * is converted into lowercased words dasherized. Any extra "/" will also be removed.
 *
 * @param str - String to be converted to dasherized case
 */
function convertToTypable(name) {
    const split = name.split(" ");
    const lowercasedWords = split.map((word) => word.toLowerCase().replace(/\//g, ""));
    return lowercasedWords.join("-");
}
exports.convertToTypable = convertToTypable;
function toNearestHundreth(n) {
    return Math.round(n * 100) / 100;
}
exports.toNearestHundreth = toNearestHundreth;
exports.chalkScheme = {
    white: chalk.rgb(255, 255, 255),
    warning: chalk.rgb(255, 174, 66),
    header: chalk.rgb(255, 255, 255),
    regress: chalk.rgb(239, 100, 107),
    neutral: chalk.rgb(225, 225, 225),
    significant: chalk.rgb(0, 191, 255),
    imprv: chalk.rgb(135, 197, 113),
    phase: chalk.rgb(225, 225, 225),
    faint: chalk.rgb(80, 80, 80),
    checkmark: chalk.rgb(133, 153, 36)(`${logSymbols.success}`),
    blackBgGreen: chalk.green.bgGreen,
    blackBgRed: chalk.rgb(239, 100, 107).bgRed,
    blackBgBlue: chalk.rgb(24, 132, 228).bgRgb(24, 132, 228),
    blackBgYellow: chalk.rgb(255, 174, 66).bgRgb(255, 174, 66),
    tbBranding: {
        lime: chalk.rgb(199, 241, 106),
        blue: chalk.rgb(24, 132, 228),
        aqua: chalk.rgb(56, 210, 211),
        dkBlue: chalk.rgb(10, 45, 70),
        grey: chalk.rgb(153, 153, 153),
    },
};
function convertToSentCase(str) {
    const result = str.replace(/([A-Z])/g, " $1");
    return result.charAt(0).toUpperCase() + result.slice(1);
}
exports.convertToSentCase = convertToSentCase;
function logHeading(heading) {
    console.log(`\n${exports.chalkScheme.blackBgBlue(`    ${exports.chalkScheme.white(heading)}    `)}\n`);
}
exports.logHeading = logHeading;
function logBar(ops) {
    const maxBarLength = 60;
    const barTick = "â– ";
    const barSegment = ops.totalDuration / maxBarLength;
    const fullSegments = ops.duration / barSegment;
    const emptySegments = maxBarLength - fullSegments;
    const bar = `${exports.chalkScheme.tbBranding.blue(barTick.repeat(fullSegments))}${exports.chalkScheme.tbBranding.grey(barTick.repeat(emptySegments))}`;
    return `${ops.title}\n${bar} ${ops.duration} ms\n`;
}
exports.logBar = logBar;
function timestamp() {
    return new Date().getTime();
}
exports.timestamp = timestamp;
function durationInSec(endTime, startTime) {
    return Math.round((endTime - startTime) / 1000);
}
exports.durationInSec = durationInSec;
//# sourceMappingURL=utils.js.map